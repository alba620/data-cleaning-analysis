---
title: <center> Limpieza y análisis de datos del mercado inmobiliario </center>
author: "Alba Gómez Varela | Patricia Lázaro Tello"
output:
  html_document:
    theme: flatly
    highlight: tango
    number_sections: yes
    toc: yes
    toc_float: 
      collapsed: no
    df_print: paged
  pdf_document:
    toc: yes
encoding: UTF-8
bibliography: real-estate.bib
csl: iso690-author-date-fr.csl
nocite: '@*'
lang: es
---
```{css, echo=FALSE}
h4 {
  text-align: center;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE,
                      fig.align = 'center', fig.height = 4, fig.width = 9, dpi = 256)
options(scipen=99999, digits=2)
knitr::knit_hooks$set(inline = function(x) {
  if(!is.numeric(x)){x}
  else{prettyNum(round(x,2), big.mark='.', decimal.mark=',')}
  })
# carga de librerias
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('tidyr')) install.packages('tidyr'); library('tidyr')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('caret')) install.packages('caret'); library('caret')
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('plotly')) install.packages('plotly'); library('plotly')
if (!require('GGally')) install.packages('GGally'); library('GGally')
if (!require('scales')) install.packages('scales'); library('scales')
if (!require('RColorBrewer')) install.packages('RColorBrewer'); library('RColorBrewer')
if(!require('ggpubr')) install.packages('ggpubr'); library('ggpubr')
if(!require('kableExtra')) install.packages('kableExtra'); library('kableExtra')
# definicion de colores
default.color.main <- '#F8766D'
default.color.secondary <- '#00BFC4'
default.color.terciary <- '#7CAE00'
default.color.quat <- '#6C25BE'
default.color.cinq <- '#FFB800'
default.color.six <- '#1C1D21'
default.color.seven <- '#003049'
default.color.eight <- '#8A2E3A'
default.color.nine <- '#093824'
# beautify plots
ggally.dist.aes <- list(continuous=wrap('points', shape=21))
palette <- c(default.color.main, default.color.secondary, 
             default.color.terciary, default.color.quat,
             default.color.cinq, default.color.six,
             default.color.seven, default.color.eight, default.color.nine)
palette.binary <- c(default.color.main, default.color.secondary)
title.centered <- theme(
  plot.title=element_text(face='bold', hjust=0.5, vjust=0.5, size=16),
  plot.title.position='plot',
  axis.title.x=element_text(size=12),
  axis.title.y=element_text(size=12),
  plot.subtitle=element_text(face='plain', hjust=0.5, vjust=0.5, size=11,
                             colour='grey50')
  )
no.axis.y <- theme(axis.text.y=element_blank(), axis.ticks.y=element_blank())
no.axis.x <- theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())
# seed
seed <- 50L
set.seed(seed)
```

# Introducción y descripción del *dataset*

# Integración, selección y transformación de datos

En primer lugar, se procede a **cargar los datos** *raw* obtenidos del repositorio [Zenodo](https://zenodo.org/record/6423459), creado el 7 de abril de 2022 para la Práctica 1 de esta asignatura. En dicho fichero, ya se encuentran integrados los registros obtenidos tras el proceso de *scraping* de Idealista y de Fotocasa, por lo que no es necesario realizar de nuevo el proceso para la fusión de los datos.

```{r}
houses.raw <- read.csv('../data/real-estate-raw.csv', header=TRUE, sep=',', 
                       stringsAsFactors=FALSE, fileEncoding='UTF-8')
houses.raw.dim <- dim(houses.raw)
```

Se han cargado **`r houses.raw.dim[1]` registros** con **`r houses.raw.dim[2]` campos** asociados a cada uno. Así, se muestran **5 registros aleatorios** para comprobar la estructura del conjunto de datos, puesto que si se seleccionan los del principio (*head*) o final (*tail*) todos serán de la misma fuente de datos:

```{r}
houses.raw[sample(nrow(houses.raw), 5), ]
```

Además, se examina el **tipo de datos** con los que R ha interpretado cada variable:

```{r}
Form.Basic = c("striped", "hover", "condensed", "responsive")
kbl(cbind(sapply(houses.raw, class)),
    caption="Tipo de datos de cada variable") %>%
  kable_styling(bootstrap_options = Form.Basic) %>%
  scroll_box(width = "100%", 
             height = "400px")
```

Para finalizar la fase de integración de los datos, se eliminan las **viviendas duplicadas**, es decir, aquellos anuncios que contengan la misma vivienda en venta. Para ello, se evalúa cuáles tienen idéntico el campo *description*, puesto que pueden ser anuncios diferentes (con diferente *id* o *source*) pero con el mismo contenido. Para profundizar en el asunto y poderlo analizar mejor se extraen en un nuevo *dataframe* las viviendas duplicadas según este criterio.

```{r}
duplicated.houses <- houses.raw[duplicated(houses.raw$description), ]
```

Así, por ejemplo, consecuencia del proceso de integración se pueden encontrar anuncios **procedentes de Fotocasa e Idealista** que contienen la misma vivienda:

```{r}
duplicated_integration <- duplicated.houses[duplicated.houses$id == '161630827' | 
                                        duplicated.houses$id == '97136644', 
                                      c('description', 'source', 'location', 'price')]

duplicated_integration
```

Por otro lado, se observa como fenómeno que también existen viviendas ofertadas varias veces en el **mismo portal** inmobiliario:

```{r}
duplicated_source <- duplicated.houses[duplicated.houses$id == '157307581' | 
                                         duplicated.houses$id == '160123208'| 
                                         duplicated.houses$id == '162766808'|
                                         duplicated.houses$id == '96250173'|
                                         duplicated.houses$id == '91151646'|
                                         duplicated.houses$id == '96890387'|
                                         duplicated.houses$id == '91334123'|
                                         duplicated.houses$id == '96857738',
                                      c('description', 'source', 'location', 'price')]

duplicated_source
```

Con esta información, se deciden eliminar las **viviendas duplicadas** y, en caso de que se encuentre en ambos sitios web, se mantiene la vivienda de Fotocasa al contener información en el campo *rooms*, asunto que se trabajará más adelante. Fotocasas se selecciona por defecto porque es el primer registro que aparece en el *dataframe* original:

```{r}
houses.unique = houses.raw[!duplicated(houses.raw$description),]
```

Sin registros duplicados, se pasa a la selección de los datos de interés, que conlleva una reducción de la dimensionalidad. Se lista a continuación cada campo, una breve descripción del mismo y si se selecciona o no, así como los motivos de la decisión:

- **id**: identificador numérico para cada registro. Actúa como identificador único junto al campo *source*. Se decide mantener los campos identificadores.
- **url**: enlace a la página de venta de la vivienda Se descarta debido a que no se puede obtener más información de la ya obtenida en la práctica anterior y a que los anuncios pueden haber desaparecido.
- **title**: título del anuncio. Se descarta por no ofrecer información adicional.
- **location**: barrio en que se encuentra la vivienda anunciada. Puede ofrecer información relevante sobre la variabilidad de precios en el mercado inmobiliario y permite agrupar los anuncios por zonas. Será importante en la parte de análisis.
- **price**: precio en euros.
- **m2**: metros cuadrados de la vivienda. Permite distinguir el tamaño de las viviendas y realizar agrupaciones.
- **price.m2**: se creará una nueva variable que contenga el valor del precio por metro cuadrado en euros de la vivienda.
- **rooms**: número de habitaciones de la vivienda. Junto a **m2** permite describir sus características físicas.
- **floor**: altura a la que se encuentra la vivienda. Ayuda a las descripción de sus características físicas. 
- **num.photos**: número de fotos que acompañan al anuncio. Se puede analizar si existe correlación entre algún tipo de vivienda (caras, baratas, con peores o mejores características) y el número de fotos.
- **floor.plan**: valor lógico que indica si se ha adjuntado el plano de la casa al anuncio.
- **view3d**: valor lógico que indica si el anuncio cuenta con la característica de visión en 3D.
- **video**: valor lógico que indica si el anuncio cuenta con un vídeo de la vivienda
- **home.staging**: valor lógico que indica si el anuncio cuenta con la característica de *home staging*.
- **description**: descripción del cuerpo del anuncio. Se mantiene por si su análisis sirviera de utilidad en el análisis futuro, aunque un análisis textual supera el contexto de la asignatura. 
- **description_length**: se creará un campo nuevo ``description_length`` con el número de palabras contenidas en la descripción para futuros análisis.
- **photo_urls**: lista de los enlaces de las fotografías adjuntas al anuncio. Se descarta por no realizar un análisis de las fotografías.
- **source**: cadena de texto que indica la fuente de la que se ha extraído la información del anuncio. Solo existen los valores "idealista" y "fotocasa". Forma parte del identificador único de cara registro y sirve, además, para agrupar viviendas.

Como se ha observado que todos los campos se han codificado como cadenas de caracteres, se optimiza la fase de **selección** de datos realizando también la **transformación** del tipo de datos. Así, a continuación se eliminan las variables descartadas, se crean las nuevas y se transforman los datos y se muestran 5 registros al azar:

```{r}
selected.houses <- houses.unique %>% dplyr::select(-url, -title, -photo_urls) %>%  
  dplyr::mutate(id = as.integer(id), 
                location = as.factor(location),
                price = as.integer(str_remove_all(price, '\\.')),
                m2 = as.integer(m2), 
                price.m2 = as.double(price/m2),
                rooms = as.integer(rooms),
                floor = as.factor(floor), 
                num.photos = as.integer(num.photos), 
                floor.plan = as.logical(as.integer(floor.plan)),
                view3d = as.logical(as.integer(view3d)), 
                video = as.logical(as.integer(video)),
                home.staging = as.logical(as.integer(home.staging)),
                description = description,
                description.length = nchar(description),
                source = as.factor(source))
selected.houses.dim <- dim(selected.houses)
houses.raw[sample(nrow(selected.houses), 5), ]
```

Finalmente, debido a que la cantidad de registros no es muy elevada, se decide **no reducirlos** mediante ningún método.

Por tanto, el conjunto de datos con el que se trabajará durante el resto del estudio está compuesto de **`r selected.houses.dim[1]` registros** con **`r selected.houses.dim[2]` campos** por cada registro. En este punto, y antes de continuar con la limpieza de datos, es interesante mostrar la estructura completa del *dataframe*:

```{r}
str(selected.houses)
```

# Limpieza de los datos

Tras haber seleccionado los datos útiles, el siguiente paso en el análisis consiste en la limpieza y normalización de los datos. En esta fase, es necesario gestionar los registros con valores perdidos o ***missing data***, así como comprobar la distribución de ciertos tipos de datos (por ejemplo, el precio de la vivienda o los $m^2$) para inspeccionar la existencia de valores extremos o ***outliers***. Sin embargo, tanto en la visualización de registros aleatorios del *dataframe* como en el estudio de la estructura, se ha detectado que hay campos que todavía deben tratarse mediante un proceso de **transformación previa** ya que su resultado puede afectar tanto a la gestión de *missing data* como de *outliers*. 

## Transformaciones previas

Varios de los campos del *dataset* son factores y pueden albergar valores ligeramente distintos que hagan referencia al mismo concepto. Se procede a comprobar los valores de estos campos para decidir sobre su necesidad de unificarlos:

```{r}
levels(selected.houses$location)
levels(selected.houses$floor)
levels(selected.houses$source)
```

El campo ***source*** contiene solo los valores esperados. El campo ***location*** contiene un nivel incorrecto y el campo ***floor*** contiene información redundante en varios niveles, además de un nivel incorrecto. Se decide descartar la información de si la vivienda es interior o exterior y si posee o no ascensor contenida en *floor*, por lo que se cambiará el tipo de dato de *floor* a entero, cuya información será útil en futuros análisis.

Para ello, en primer lugar se eliminan los **niveles incorrectos** de *location* y *floor*:

```{r}
selected.houses <- droplevels.data.frame(selected.houses)
```

A continuación, se modifica el campo *floor* para obtener únicamente la **planta de la vivienda**. Si la vivienda no tiene planta (el caso de "Sin planta"), se le asigna la planta 0, conclusión a la que se llega tras la exploración de los datos y verificación por la información del campo *description*: 

```{r}
selected.houses <- selected.houses %>% 
  dplyr::mutate(floor=as.character(floor)) %>%
  dplyr::mutate(floor=ifelse(floor=='Sin planta', '0', floor)) %>%
  dplyr::mutate(floor=readr::parse_number(floor)) %>% 
  dplyr::mutate(floor=as.factor(floor))
levels(selected.houses$floor)
```

## Gestión de *Missing Data*

Se procede a realizar un análisis preliminar y superficial de los **valores perdidos** en todos los campos:

```{r}
kable(colSums(is.na(selected.houses)),
      digits=2, 
      align='l', 
      caption="Valores nulos en cada variable") %>%
  kable_styling(bootstrap_options = Form.Basic) %>%
    scroll_box(width = "100%", height = "470px")
```
Como se puede observar, el campo *rooms* es el que tiene más valores perdidos, por lo que se tratará más adelante. Así, se visualizan los registros que contienen valores perdidos en las variables *id*, *price* o *floor*:

```{r}
selected.houses[is.na(selected.houses$id) | 
                  is.na(selected.houses$price) | 
                  is.na(selected.houses$floor),]
```

Solo existe `r sum(is.na(selected.houses$id))` registro sin identificador, `r sum(is.na(selected.houses$price))` registro sin precio y `r sum(is.na(selected.houses$floor))` sin planta. Dadas las características de los registros (demasiados campos con valores perdidos y otros campos con valores incorrectos en el registro sin identificador) se decide eliminar los registros.

```{r}
selected.houses <- selected.houses[!is.na(selected.houses$id) & 
                                     !is.na(selected.houses$price) &
                                     !is.na(selected.houses$floor),]
```

Se procede ahora a analizar los registros con valores perdidos en el campo *rooms* y, para ello, se decide mostrar todos los registros en busca de un patrón:

```{r}
selected.houses[is.na(selected.houses$rooms),]
```

Se trata de `r sum(is.na(selected.houses$rooms))` registros que no tienen valor en el campo *rooms*. Se trata del `r sum(is.na(selected.houses$rooms))*100.0/selected.houses.dim[1]`% del total de registros pero se observa claramente que se trata de viviendas que proceden de Idealista. Se verifica dicha suposición:

```{r}
if(length(which(is.na(selected.houses$rooms))) == 
   length(selected.houses$source[selected.houses$source == 'idealista'])){
  print("El número de viviendas sin valor en 'rooms' SÍ es igual al de procedentes de Idealista.")
} else {
  print("El número de viviendas sin valor en 'rooms' NO es igual al de procedentes de Idealista.")
}
```
Por tanto, se decide **mantener todos los registros** sin valor en *rooms* y se tiene en cuenta para futuros análisis que si se quiere emplear esta variable solamente se podrán tener en cuentra las viviendas procedentes del portal web de **Fotocasa**. Otras opciones habrían contemplado eliminar el campo completamente del *dataset*, predecir el número de habitaciones dado el resto de características o imputarles un valor arbitrario, como 0.

## Gestión de *outliers*

Tras el trabajo que se ha realizado con los datos, se puede deducir que los **valores extremos**, o *outliers*, solo pueden encontrarse en las variables *price*, *m2*, *rooms*, *floor* (en este momento categórica), *num.photos*, *price.m2* y *description.length*.

Para explorar cada uno de los casos, se realiza una aproximación gráfica a cada problema mediante ***boxplots*** o diagramas de caja y se decide qué hacer con los candidatos a *outliers*. 

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$price, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(type = "log", 
                      title = "Precio en escala logarítmica"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del precio según el barrio")
```
```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$m2, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list( title = "Metros cuadrados"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución de los metros cuadrados según el barrio")
```

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$rooms, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list( title = "Número de habitaciones"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del número de habitaciones según el barrio")
```

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$floor, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list( title = "Planta"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución de la planta según el barrio")
```

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$num.photos, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list( title = "Número de fotografías"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del número de fotografías según el barrio")
```
```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$price.m2, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(type = "log", 
                      title = "Precio por metro cuadrado en escala logarítmica"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del precio por metro cuadrado según el barrio")
```
```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$description.length, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(title = "Longitud de la descripción"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución de la longitud del anuncio según el barrio")
```
# Análisis de los datos


## Selección de grupos de datos


## Comprobación de normalidad y homocedasticidad


## Pruebas estadísticas


# Conclusiones

\newpage

# Bibliografía
