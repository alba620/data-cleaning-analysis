---
title: <center> Limpieza y análisis de datos del mercado inmobiliario </center>
author: "Alba Gómez Varela | Patricia Lázaro Tello"
output:
  html_document:
    theme: flatly
    highlight: tango
    number_sections: yes
    toc: yes
    toc_float: 
      collapsed: no
    df_print: paged
  pdf_document:
    toc: yes
encoding: UTF-8
bibliography: real-estate.bib
csl: iso690-author-date-fr.csl
nocite: '@*'
lang: es
---
```{css, echo=FALSE}
h4 {
  text-align: center;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE,
                      fig.align = 'center', fig.height = 4, fig.width = 9, dpi = 256)
options(scipen=99999, digits=2)
knitr::knit_hooks$set(inline = function(x) {
  if(!is.numeric(x)){x}
  else{prettyNum(round(x,2), big.mark='.', decimal.mark=',')}
  })

# carga de librerias
if (!require('tidyverse')) install.packages('tidyverse'); library('tidyverse')
if (!require('tidyr')) install.packages('tidyr'); library('tidyr')
if (!require('dplyr')) install.packages('dplyr'); library('dplyr')
if (!require('caret')) install.packages('caret'); library('caret')
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('plotly')) install.packages('plotly'); library('plotly')
if (!require('GGally')) install.packages('GGally'); library('GGally')
if (!require('scales')) install.packages('scales'); library('scales')
if (!require('RColorBrewer')) install.packages('RColorBrewer'); library('RColorBrewer')
if(!require('ggpubr')) install.packages('ggpubr'); library('ggpubr')
if(!require('kableExtra')) install.packages('kableExtra'); library('kableExtra')
if (!require('nortest')) install.packages('nortest'); library('nortest')
if (!require('car')) install.packages('car'); library('car')

# definicion de colores
default.color.main <- '#F8766D'
default.color.secondary <- '#00BFC4'
default.color.terciary <- '#7CAE00'
default.color.quat <- '#6C25BE'
default.color.cinq <- '#FFB800'
default.color.six <- '#1C1D21'
default.color.seven <- '#003049'
default.color.eight <- '#8A2E3A'
default.color.nine <- '#093824'

# beautify plots
ggally.dist.aes <- list(continuous=wrap('points', shape=21))
palette <- c(default.color.main, default.color.secondary, 
             default.color.terciary, default.color.quat,
             default.color.cinq, default.color.six,
             default.color.seven, default.color.eight, default.color.nine)
palette.binary <- c(default.color.main, default.color.secondary)
title.centered <- theme(
  plot.title=element_text(face='bold', hjust=0.5, vjust=0.5, size=16),
  plot.title.position='plot',
  axis.title.x=element_text(size=12),
  axis.title.y=element_text(size=12),
  plot.subtitle=element_text(face='plain', hjust=0.5, vjust=0.5, size=11,
                             colour='grey50')
  )
no.axis.y <- theme(axis.text.y=element_blank(), axis.ticks.y=element_blank())
no.axis.x <- theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())

# seed
seed <- 50L
set.seed(seed)
```

# Introducción y descripción del *dataset*

# Integración, selección y transformación de datos

En primer lugar, se procede a **cargar los datos** *raw* obtenidos del repositorio [Zenodo](https://zenodo.org/record/6423459), creado el 7 de abril de 2022 para la Práctica 1 de esta asignatura. En dicho fichero, ya se encuentran integrados los registros obtenidos tras el proceso de *scraping* de Idealista y de Fotocasa, por lo que no es necesario realizar de nuevo el proceso para la fusión de los datos.

```{r}
houses.raw <- read.csv('../data/real-estate-raw.csv', header=TRUE, sep=',', 
                       stringsAsFactors=FALSE, fileEncoding='UTF-8')
houses.raw.dim <- dim(houses.raw)
```

Se han cargado **`r houses.raw.dim[1]` registros** con **`r houses.raw.dim[2]` campos** asociados a cada uno. Así, se muestran **5 registros aleatorios** para comprobar la estructura del conjunto de datos, puesto que si se seleccionan los del principio (*head*) o final (*tail*) todos serán de la misma fuente de datos:

```{r}
houses.raw[sample(nrow(houses.raw), 5), ]
```

Además, se examina el **tipo de datos** con los que R ha interpretado cada variable:

```{r}
Form.Basic = c("striped", "hover", "condensed", "responsive")
kbl(cbind(sapply(houses.raw, class)),
    caption="Tipo de datos de cada variable") %>%
  kable_styling(bootstrap_options = Form.Basic) %>%
  scroll_box(width = "100%", 
             height = "400px")
```

Para finalizar la fase de integración de los datos, se eliminan las **viviendas duplicadas**, es decir, aquellos anuncios que contengan la misma vivienda en venta. Para ello, se evalúa cuáles tienen idéntico el campo *description*, puesto que pueden ser anuncios diferentes (con diferente *id* o *source*) pero con el mismo contenido. Para profundizar en el asunto y poderlo analizar mejor se extraen en un nuevo *dataframe* las viviendas duplicadas según este criterio.

```{r}
duplicated.houses <- houses.raw[duplicated(houses.raw$description), ]
```

Así, por ejemplo, consecuencia del proceso de integración se pueden encontrar anuncios **procedentes de Fotocasa e Idealista** que contienen la misma vivienda:

```{r}
duplicated_integration <- duplicated.houses[duplicated.houses$id == '161630827' | 
                                        duplicated.houses$id == '97136644', 
                                      c('description', 'source', 'location', 'price')]

duplicated_integration
```

Por otro lado, se observa como fenómeno que también existen viviendas ofertadas varias veces en el **mismo portal** inmobiliario:

```{r}
duplicated_source <- duplicated.houses[duplicated.houses$id == '157307581' | 
                                         duplicated.houses$id == '160123208'| 
                                         duplicated.houses$id == '162766808'|
                                         duplicated.houses$id == '96250173'|
                                         duplicated.houses$id == '91151646'|
                                         duplicated.houses$id == '96890387'|
                                         duplicated.houses$id == '91334123'|
                                         duplicated.houses$id == '96857738',
                                      c('description', 'source', 'location', 'price')]

duplicated_source
```

Con esta información, se deciden eliminar las **viviendas duplicadas** y, en caso de que se encuentre en ambos sitios web, se mantiene la vivienda de Fotocasa al contener información en el campo *rooms*, asunto que se trabajará más adelante. Fotocasas se selecciona por defecto porque es el primer registro que aparece en el *dataframe* original:

```{r}
houses.unique = houses.raw[!duplicated(houses.raw$description),]
```

Sin registros duplicados, se pasa a la selección de los datos de interés, que conlleva una reducción de la dimensionalidad. Se lista a continuación cada campo, una breve descripción del mismo y si se selecciona o no, así como los motivos de la decisión:

- **id**: identificador numérico para cada registro. Actúa como identificador único junto al campo *source*. Se decide mantener los campos identificadores.
- **url**: enlace a la página de venta de la vivienda Se descarta debido a que no se puede obtener más información de la ya obtenida en la práctica anterior y a que los anuncios pueden haber desaparecido.
- **title**: título del anuncio. Se descarta por no ofrecer información adicional.
- **location**: barrio en que se encuentra la vivienda anunciada. Puede ofrecer información relevante sobre la variabilidad de precios en el mercado inmobiliario y permite agrupar los anuncios por zonas. Será importante en la parte de análisis.
- **price**: precio en euros.
- **m2**: metros cuadrados de la vivienda. Permite distinguir el tamaño de las viviendas y realizar agrupaciones.
- **price.m2**: se creará una nueva variable que contenga el valor del precio por metro cuadrado en euros de la vivienda.
- **rooms**: número de habitaciones de la vivienda. Junto a **m2** permite describir sus características físicas.
- **floor**: altura a la que se encuentra la vivienda. Ayuda a las descripción de sus características físicas. 
- **num.photos**: número de fotos que acompañan al anuncio. Se puede analizar si existe correlación entre algún tipo de vivienda (caras, baratas, con peores o mejores características) y el número de fotos.
- **floor.plan**: valor lógico que indica si se ha adjuntado el plano de la casa al anuncio.
- **view3d**: valor lógico que indica si el anuncio cuenta con la característica de visión en 3D.
- **video**: valor lógico que indica si el anuncio cuenta con un vídeo de la vivienda
- **home.staging**: valor lógico que indica si el anuncio cuenta con la característica de *home staging*.
- **description**: descripción del cuerpo del anuncio. Se mantiene por si su análisis sirviera de utilidad en el análisis futuro, aunque un análisis textual supera el contexto de la asignatura. 
- **description_length**: se creará un campo nuevo ``description_length`` con el número de palabras contenidas en la descripción para futuros análisis.
- **photo_urls**: lista de los enlaces de las fotografías adjuntas al anuncio. Se descarta por no realizar un análisis de las fotografías.
- **source**: cadena de texto que indica la fuente de la que se ha extraído la información del anuncio. Solo existen los valores "idealista" y "fotocasa". Forma parte del identificador único de cara registro y sirve, además, para agrupar viviendas.

Como se ha observado que todos los campos se han codificado como cadenas de caracteres, se optimiza la fase de **selección** de datos realizando también la **transformación** del tipo de datos. Así, a continuación se eliminan las variables descartadas, se crean las nuevas y se transforman los datos y se muestran 5 registros al azar:

```{r}
selected.houses <- houses.unique %>% dplyr::select(-url, -title, -photo_urls) %>%  
  dplyr::mutate(id = as.integer(id), 
                location = as.factor(location),
                price = as.integer(str_remove_all(price, '\\.')),
                m2 = as.integer(m2), 
                price.m2 = as.double(price/m2),
                rooms = as.integer(rooms),
                floor = as.factor(floor), 
                num.photos = as.integer(num.photos), 
                floor.plan = as.logical(as.integer(floor.plan)),
                view3d = as.logical(as.integer(view3d)), 
                video = as.logical(as.integer(video)),
                home.staging = as.logical(as.integer(home.staging)),
                description = description,
                description.length = nchar(description),
                source = as.factor(source))
selected.houses.dim <- dim(selected.houses)
houses.raw[sample(nrow(selected.houses), 5), ]
```

Finalmente, debido a que la cantidad de registros no es muy elevada, se decide **no reducirlos** mediante ningún método.

Por tanto, el conjunto de datos con el que se trabajará durante el resto del estudio está compuesto de **`r selected.houses.dim[1]` registros** con **`r selected.houses.dim[2]` campos** por cada registro. En este punto, y antes de continuar con la limpieza de datos, es interesante mostrar la estructura completa del *dataframe*:

```{r}
str(selected.houses)
```

# Limpieza de los datos

Tras haber seleccionado los datos útiles, el siguiente paso hacia el análisis consiste en la limpieza y normalización de los datos. En esta fase, es necesario gestionar los registros con valores perdidos o ***missing data***, así como comprobar la distribución de ciertos tipos de datos (por ejemplo, el precio de la vivienda o los $m^2$) para inspeccionar la existencia de valores extremos o ***outliers***. Sin embargo, tanto en la visualización de registros aleatorios del *dataframe* como en el estudio de la estructura, se ha detectado que hay campos que todavía deben tratarse mediante un proceso de **transformación previa** ya que su resultado puede afectar tanto a la gestión de *missing data* como de *outliers*. 

## Transformaciones previas

Varios de los campos del *dataset* son factores y pueden albergar valores ligeramente distintos que hagan referencia al **mismo concepto**. Se procede a comprobar los valores de estos campos para decidir sobre su necesidad de unificarlos:

```{r}
levels(selected.houses$location)
levels(selected.houses$floor)
levels(selected.houses$source)
```

El campo ***source*** contiene solo los valores esperados. El campo ***location*** contiene un nivel incorrecto y el campo ***floor*** contiene información redundante en varios niveles, además de un nivel incorrecto. Se decide descartar la información de si la vivienda es interior o exterior y si posee o no ascensor contenida en *floor*, dejando como valor de *floor* su planta, cuya información será útil en futuros análisis.

Para ello, en primer lugar se eliminan los **niveles incorrectos** de *location* y *floor*:

```{r}
selected.houses <- droplevels.data.frame(selected.houses)
```

A continuación, se modifica el campo *floor* para obtener únicamente la **planta de la vivienda**. Si la vivienda no tiene planta (el caso de "Sin planta"), se le asigna la planta 0, conclusión a la que se llega tras la exploración de los datos y verificación por la información del campo *description*: 

```{r}
selected.houses <- selected.houses %>% 
  dplyr::mutate(floor=as.character(floor)) %>%
  dplyr::mutate(floor=ifelse(floor=='Sin planta', '0', floor)) %>%
  dplyr::mutate(floor=readr::parse_number(floor)) %>% 
  dplyr::mutate(floor=as.factor(floor))
levels(selected.houses$floor)
```

## Gestión de *Missing Data*

Se procede a realizar un análisis preliminar y superficial de los **valores perdidos** en todos los campos:

```{r}
kable(colSums(is.na(selected.houses)),
      digits=2, 
      align='l', 
      caption="Valores nulos en cada variable") %>%
  kable_styling(bootstrap_options = Form.Basic) %>%
    scroll_box(width = "100%", height = "470px")
```

Como se puede observar, el campo *rooms* es el que tiene más valores perdidos, por lo que se tratará más adelante. Así, se visualizan los registros que contienen valores perdidos en las variables ***id***, ***price*** y ***floor***:

```{r}
selected.houses[is.na(selected.houses$id) | 
                  is.na(selected.houses$price) | 
                  is.na(selected.houses$floor),]
```

Solo existe `r sum(is.na(selected.houses$id))` registro sin identificador, `r sum(is.na(selected.houses$price))` registro sin precio y `r sum(is.na(selected.houses$floor))` sin planta. Dadas las características de los registros (demasiados campos con valores perdidos y otros campos con valores incorrectos en el registro sin identificador) se decide eliminar los registros.

```{r}
selected.houses <- selected.houses[!is.na(selected.houses$id) & 
                                     !is.na(selected.houses$price) &
                                     !is.na(selected.houses$floor),]
```

Se procede ahora a analizar los registros con valores perdidos en el campo ***rooms*** y, para ello, se decide mostrar todos los registros en busca de un patrón:

```{r}
selected.houses[is.na(selected.houses$rooms),]
```

Se trata de `r sum(is.na(selected.houses$rooms))` registros que no tienen valor en el campo ***rooms***. Se trata del `r sum(is.na(selected.houses$rooms))*100.0/selected.houses.dim[1]`% del total de registros pero, se observa claramente que se trata de viviendas que proceden de **Idealista**. Se verifica dicha suposición:

```{r}
if(length(which(is.na(selected.houses$rooms))) == 
   length(selected.houses$source[selected.houses$source == 'idealista'])){
  print("El número de viviendas sin valor en 'rooms' SÍ es igual al de procedentes de Idealista.")
} else {
  print("El número de viviendas sin valor en 'rooms' NO es igual al de procedentes de Idealista.")
}
```

Por tanto, se decide **mantener todos los registros** sin valor en *rooms* y se tiene en cuenta para futuros análisis que si se quiere emplear esta variable solamente se podrán analizar las viviendas procedentes del portal web de **Fotocasa**. Otras opciones habrían contemplado eliminar el campo completamente del *dataset*, predecir el número de habitaciones dado el resto de características o imputarles un valor arbitrario, como 0.

## Gestión de *outliers*

Tras el trabajo que se ha realizado con los datos, se puede deducir que los **valores extremos**, o *outliers*, solo pueden encontrarse en las variables *price*, *m2*, *rooms*, *floor* (en este momento categórica), *num.photos*, *price.m2* y *description.length*.

Como en la primera entrega de este proyecto (Práctica 1) ya se determinó que los barrios de Salamanca y Villaverde de Madrid se encuentran en los extremos de precios dentro de la ciudad según todas las fuentes consultadas, para no distorsionar el análisis de *outliers*, se opta por estudiar cada variable según la **ubicación de la vivienda**. 

Para explorar cada uno de los casos, se realiza una aproximación gráfica a cada problema mediante ***boxplots*** o diagramas de caja **interactivos** que facilitan la identificación de los registros, comprensión e identificación, y se decide qué hacer con los candidatos a *outliers*. 

En primer lugar, se analiza el **precio**:

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$price, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(type = "log", 
                      title = "Precio en escala logarítmica"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del precio según el barrio")
```

Que haya viviendas caras hasta tal punto que su precio parezca un posible valor extremo equivocado no debe sorprender en este proyecto debido a que el mercado inmobiliario se caracteriza precisamente por ello. En cualquier caso, para verificar que estos **precios son compatibles con la realidad**, se opta por extraer los registros de las viviendas sospechosas:

```{r}
villaverde.price <- selected.houses[selected.houses$price %in% 
                  boxplot.stats(selected.houses$price[selected.houses$location == 
                                                        'villaverde'])$out & 
                  selected.houses$location == 'villaverde' ,]

salamanca.price <- selected.houses[selected.houses$price %in% 
                  boxplot.stats(selected.houses$price[selected.houses$location == 
                                                        'barrio-de-salamanca'])$out & 
                  selected.houses$location == 'barrio-de-salamanca' ,]
```

Tras estudiar los 165 registros en profundidad, se descubre que en ambos barrios los viviendas consideradas atípicamente caras también son **muy grandes** para la zona en la que se encuentran:

```{r}
min(villaverde.price$m2)
min(salamanca.price$m2)
```

Por tanto se decide **no tratar** dichos registros al encontrarse dentro del rango de lo posible en este contexto, como se puede deducir del tamaño mínimo de estas viviendas. 

A continuación se analiza el **precio por metro cuadrado**

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$price.m2, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(type = "log", 
                      title = "Precio por metro cuadrado en escala logarítmica"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del precio por metro cuadrado según el barrio")
```

Como en el caso anterior, se extraen los **registros de las viviendas** que tienen un precio atípicamente alto o bajo en relación con sus metros cuadradados para cada uno de los barrios de Madrid analizados:

```{r}
villaverde.price.m2 <- selected.houses[selected.houses$price.m2 %in% 
                  boxplot.stats(selected.houses$price.m2[selected.houses$location == 
                                                           'villaverde'])$out & 
                  selected.houses$location == 'villaverde' ,]

salamanca.price.m2 <- selected.houses[selected.houses$price.m2 %in% 
                  boxplot.stats(selected.houses$price.m2[selected.houses$location == 
                                                           'barrio-de-salamanca'])$out & 
                  selected.houses$location == 'barrio-de-salamanca' ,]
```

Tras estudiar los **51 registros** en profundidad, no se encuentra un patrón que pudiera explicar esta situación y los valores del resto de campos son coherentes con el ámbito de este proyecto. Si embargo, sí que se detecta que las tres viviendas con un precio más bajo por metro cuadradado en Villaverde no son tal, sino que se trata de **parcelas** según se explica en el campo *description*, por lo que se procede a su eliminación: 

```{r}

selected.houses[(selected.houses$id == "162471798") | 
                  (selected.houses$id == "159999857") | 
                  (selected.houses$id == "162471885"),]
selected.houses <- subset(selected.houses, 
                          id != "162471798" & 
                            id != "159999857" & 
                            id !="162471885")
```

Acabado el análisis sobre el precio, se pasa a estudiar el **tamaño**:

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$m2, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list( title = "Metros cuadrados"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución de los metros cuadrados según el barrio")
```

También se extraen los **registros de las viviendas** que tienen un tamaño atípicamente alto para cada uno de los barrios:

```{r}
villaverde.m2 <- selected.houses[selected.houses$m2 %in% 
                  boxplot.stats(selected.houses$m2[selected.houses$location == 
                                                     'villaverde'])$out & 
                  selected.houses$location == 'villaverde' ,]

salamanca.m2 <- selected.houses[selected.houses$m2 %in% 
                  boxplot.stats(selected.houses$m2[selected.houses$location == 
                                                     'barrio-de-salamanca'])$out & 
                  selected.houses$location == 'barrio-de-salamanca' ,]
```

Tras analizar los **122 registros** no se encuentra **ninguna anomalía** que haga sospechar de un error en los datos y el tamaño por encima de lo esperado en la zona se debe simplemente a que se trata de viviendas grandes. De hecho, en las descripciones de varias de ellas se detalla que se pueden dividir en varias viviendas o el número de plantas que tiene dentro. 

El siguiente paso es analizar el **número de habitaciones** teniendo en cuenta que este dato procede únicamente de las viviendas anunciadas en Fotocasa:

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$rooms, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list( title = "Número de habitaciones"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del número de habitaciones según el barrio")
```

Se sigue el mismo procedimiento que antes, analizando por separado los posibles *outliers* pero, como era de esperar, las **4 viviendas** con más habitaciones también son más grandes, por lo que se decide **no tratar** estos registros.

```{r}
villaverde.rooms <- selected.houses[selected.houses$rooms %in% 
                  boxplot.stats(selected.houses$rooms[selected.houses$location == 
                                                        'villaverde'])$out & 
                  selected.houses$location == 'villaverde' ,]

salamanca.rooms <- selected.houses[selected.houses$rooms %in% 
                  boxplot.stats(selected.houses$rooms[selected.houses$location == 
                                                        'barrio-de-salamanca'])$out & 
                  selected.houses$location == 'barrio-de-salamanca' ,]
```

A continuación se visualizan los candidatos a *outliers* según la **planta** en la que se encuentra la vivienda:

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$floor, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(title = "Planta"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución de la planta según el barrio")
```

Según los datos del **Catastro** en el Barrio de Salamanca de Madrid **existen edificios** de 12 alturas y en el de Villaverde de 13, e incluso más en ambos casos, aunque no es lo más común. Por tanto, cabe la posibilidad de que las viviendas en venta se encuentren en dichas plantas, por lo que no es necesario profundizar en el análisis de estos datos o los registros completos. 

En cuanto al **número de fotografías**, los *boxplots* resultantes son los siguientes:

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$num.photos, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(title = "Número de fotografías"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución del número de fotografías según el barrio")
```

si bien es cierto que el número máximo de fotografías en **Fotocasa** es de **30**, este límite asciende hasta **200** en **Idealista**, por lo que nada hace determinar que los valores atípicos sean indicativos de errores en el proceso de captura de los anuncios de las viviendas. De hecho, el anuncio con 194 imágenes corresponde al de una vivienda de casi 3 millones de euros, por lo que tiene sentido que sea el más completo de todos en este aspecto: 

```{r}
selected.houses[(selected.houses$num.photos = 194),]
```

Por úlimo, se evalúa la variable que recoge la longitud de la **descripción en caracteres**:

```{r, out.width="100%",out.height ="50%"}
plot_ly(y = ~ selected.houses$description.length, 
        color = ~ selected.houses$location, 
        type = "box") %>%
  layout(yaxis = list(title = "Longitud de la descripción"), 
         xaxis = list(title = "'Location' (barrio de la vivienda)"), 
         title = "Distribución de la longitud del anuncio según el barrio")
```

Como según la normativa de **Fotocasa** el máximo de caracteres es de **4.000** y la de **Idealista** sube este máximo hasta los **5.000** caracteres, los marcados como posibles *outliers* se consideran registros dentro de lo posible, por lo que se decide mantenerlos sin actuar sobre ellos. 

**Este apartado** ha sido útil para descartar la eliminación de posibles *outliers* y verificar la presunta corrección de los datos, excepto tres viviendas que en realidad no lo eran. Además, ha servido para tener una primera aproximación sobre las **características** de las viviendas en función de su localización. Así, aquellas situadas en el **Barrio de Salamanca** de Madrid tienden a ser **más caras** en valores absolutos y relativos, más grandes, con **más habitaciones** y con **anuncios más completos** (en número de caracteres y fotografías) que las ubicadas en el barrio de **Villaverde** de la capital. En cualquier caso, en el apartado de Análisis se llegará a conclusiones más precisas.

## Conjunto de datos final

Tras este proceso de *data cleaning* o limpieza de datos, el conjunto de datos final tiene las siguientes **características**:

```{r}
options(knitr.kable.NA = '')
kable(summary(selected.houses),
      digits=2, 
      align='l', 
      caption="Datos resumen de cada variable") %>%
  kable_styling(bootstrap_options = Form.Basic) %>%
    scroll_box(width = "100%", height = "480px")
```

Por último, se guarda el **conjunto de datos final** en un **nuevo fichero**, que también estará disponible en el repositorio público:

```{r}
write.csv(selected.houses, 
          file = '../data/real-estate.csv',
          row.names = FALSE,
          sep=',')
```

# Análisis de los datos

BLABLABLA

## Selección de grupos de datos

Teniendo en cuenta los **objetivos** marcados en la introducción y el resultado de las exploraciones realizadas en apartados anteriores, a continuación se **agrupan** las viviendas según el barrio:

```{r}
villaverde.houses <- selected.houses[selected.houses$location == "villaverde",]
salamanca.houses <- selected.houses[selected.houses$location == "barrio-de-salamanca",]
```

Además, se crean nuevas variables para facilitar la realización de pruebas estadísticas que puedan llevar a conclusiones interesantes:

```{r}
selected.houses$price.clasification <- as.factor(case_when(
                          selected.houses$price.m2 <= mean(selected.houses$price.m2) ~ "barato",    
                          selected.houses$price.m2 > mean(selected.houses$price.m2)  ~ "caro"
                          )) 

villaverde.houses$price.clasification <- as.factor(case_when(
                          villaverde.houses$price.m2 <= mean(villaverde.houses$price.m2) ~ "barato",    
                          villaverde.houses$price.m2 > mean(villaverde.houses$price.m2)  ~ "caro"
                          )) 

salamanca.houses$price.clasification <- as.factor(case_when(
                          salamanca.houses$price.m2 <= mean(salamanca.houses$price.m2) ~ "barato",    
                          salamanca.houses$price.m2 > mean(salamanca.houses$price.m2)  ~ "caro"
                          )) 
```

```{r}
selected.houses$m2.clasification <- as.factor(case_when(
                          selected.houses$m2 <= mean(selected.houses$m2) ~ "pequeño",    
                          selected.houses$m2 > mean(selected.houses$m2)  ~ "grande"
                          )) 

villaverde.houses$m2.clasification <- as.factor(case_when(
                          villaverde.houses$m2 <= mean(villaverde.houses$m2) ~ "pequeño",    
                          villaverde.houses$m2 > mean(villaverde.houses$m2)  ~ "grande"
                          )) 

salamanca.houses$m2.clasification <- as.factor(case_when(
                          salamanca.houses$m2 <= mean(salamanca.houses$m2) ~ "pequeño",    
                          salamanca.houses$m2 > mean(salamanca.houses$m2)  ~ "grande"
                          )) 
```

```{r}
selected.houses$height.clasification <- as.factor(case_when(
                          as.numeric(selected.houses$floor) <= 4 ~ "bajo",    
                          as.numeric(selected.houses$floor) > 4  ~ "alto"
                          )) 

villaverde.houses$height.clasification <- as.factor(case_when(
                          as.numeric(villaverde.houses$floor) <= 4 ~ "bajo",    
                          as.numeric(villaverde.houses$floor) > 4  ~ "alto"
                          )) 

salamanca.houses$height.clasification <- as.factor(case_when(
                          as.numeric(salamanca.houses$floor) <= 4 ~ "bajo",    
                          as.numeric(salamanca.houses$floor) > 4 ~ "alto"
                          )) 
```

Gracias a las variables creadas, se realizan **nuevas agrupaciones** de manera que las viviendas se agrupan además en caras o baratas, grandes o pequeñas y altas o bajas teniendo como referencia para este criterio el barrio en el que se encuentren:

```{r}
cheap.houses <- bind_rows(villaverde.houses[villaverde.houses$price.clasification == "barato",],
                          salamanca.houses[salamanca.houses$price.clasification == "barato",])
expensive.houses <- bind_rows(villaverde.houses[villaverde.houses$price.clasification == "caro",],
                              salamanca.houses[salamanca.houses$price.clasification == "caro",])
```

```{r}
small.houses <- bind_rows(villaverde.houses[villaverde.houses$m2.clasification == "pequeño",], 
                          salamanca.houses[salamanca.houses$m2.clasification == "pequeño",])
big.houses <- bind_rows(villaverde.houses[villaverde.houses$m2.clasification == "grande",], 
                        salamanca.houses[salamanca.houses$m2.clasification == "grande",])
```

```{r}
lower.floors.houses <- bind_rows(villaverde.houses[villaverde.houses$heigth.clasification == "bajo",], 
                                 salamanca.houses[salamanca.houses$heigth.clasification == "bajo",])
upper.floors.houses <- bind_rows(villaverde.houses[villaverde.houses$heigth.clasification == "alto",], 
                                 salamanca.houses[salamanca.houses$heigth.clasification == "alto",])
```

## Comprobación de normalidad y homocedasticidad

Se procede a comprobar si las variables cuantitativas *price*, *m2* y *price.m2* cumplen los supuestos de normalidad. A su vez, también se comprobará si el precio por m^2 cumple el supuesto de homocedasticidad para las viviendas agrupadas por barrio y las viviendas agrupadas por barrio y altura.

### Normalidad de `price`

Se procede a realizar las comprobaciones de normalidad en la variable `price`, utilizando el test de Lilliefors y la ayuda de gráficas auxiliares.

```{r fig.height=5, fig.width=10}
price.n <- length(selected.houses$price)
price.mean <- mean(selected.houses$price)
price.sd <- sd(selected.houses$price)

ggarrange(nrow=1, ncol=2, align='hv', heights=c(1, 0.75),
          ggplot(selected.houses, aes(x=price)) +
            geom_density(mapping=aes(y=..density..), fill=default.color.main) +
            geom_vline(xintercept=price.mean, size=1.05,
                       linetype='dashed', color='gray50') +
            stat_function(fun=dnorm, args=c(mean=price.mean,
                                            sd=price.sd),
                          color=default.color.secondary, size=1.15) +
            no.axis.y + xlab('Precio') + ylab('') + title.centered +
            ggtitle('Distribución de los precios de las viviendas', 
                    subtitle='Respecto a una distribución normal'),
          
          ggqqplot(selected.houses$price, color=default.color.main, 
                   ggtheme = theme_gray(), xlab='Cuantiles teóricos', 
                   ylab='Cuantiles de la muestra', title='Gráfico Q-Q', 
                   shape=16) + title.centered + xlab('') + ylab('')
          )

lillie.test(selected.houses$price)
```

Las gráficas muestran que el precio de las viviendas no sigue una distribución normal; con el test de normalidad de Lilliefors se confirma que la distribución de la variable `precio` no es normal (p-value < $\alpha$ = 0.05). Sin embargo, la variable `precio` parece seguir una distribución log-normal; es decir, el logaritmo del precio puede seguir una distribución normal. Se procede a comprobar dicha hipótesis:

```{r fig.height=5, fig.width=10}
selected.houses <- selected.houses %>% plyr::mutate(price.log = log(price))
price.log.n <- length(selected.houses$price.log)
price.log.mean <- mean(selected.houses$price.log)
price.log.sd <- sd(selected.houses$price.log)

ggarrange(nrow=1, ncol=2, align='hv', heights=c(1, 0.75),
          ggplot(selected.houses, aes(x=price.log)) +
            geom_density(mapping=aes(y=..density..), fill=default.color.main) +
            geom_vline(xintercept=price.log.mean, size=1.05,
                       linetype='dashed', color='gray50') +
            stat_function(fun=dnorm, args=c(mean=price.log.mean,
                                            sd=price.log.sd),
                          color=default.color.secondary, size=1.15) +
            no.axis.y + xlab('Log(Precio)') + ylab('') + title.centered +
            ggtitle('Distribución de los precios de las viviendas', 
                    subtitle='Respecto a una distribución normal'),
          
          ggqqplot(selected.houses$price.log, color=default.color.main, 
                   ggtheme = theme_gray(), xlab='Cuantiles teóricos', 
                   ylab='Cuantiles de la muestra', title='Gráfico Q-Q', 
                   shape=16) + title.centered + xlab('') + ylab('')
          )

lillie.test(selected.houses$price.log)
```

La variable `precio` tampoco sigue una distribución log-normal, según se aprecia tanto en los gráficos (colas muy pesadas en el qqplot) como en el test de Lilliefors (p-value < $\alpha$ = 0.05). Se concluye por tanto que la variable `precio` no sigue una distribución normal.

### Normalidad de `m2`

Se procede a realizar las comprobaciones de normalidad en la variable `m2`, utilizando el test de Lilliefors y la ayuda de gráficas auxiliares.

```{r fig.height=5, fig.width=10}
m2.n <- length(selected.houses$m2)
m2.mean <- mean(selected.houses$m2)
m2.sd <- sd(selected.houses$m2)

ggarrange(nrow=1, ncol=2, align='hv', heights=c(1, 0.75),
          ggplot(selected.houses, aes(x=m2)) +
            geom_density(mapping=aes(y=..density..), fill=default.color.main) +
            geom_vline(xintercept=m2.mean, size=1.05,
                       linetype='dashed', color='gray50') +
            stat_function(fun=dnorm, args=c(mean=m2.mean,
                                            sd=m2.sd),
                          color=default.color.secondary, size=1.15) +
            no.axis.y + xlab('m^2') + ylab('') + title.centered +
            ggtitle('Distribución de los m^2 de las viviendas', 
                    subtitle='Respecto a una distribución normal'),
          
          ggqqplot(selected.houses$m2, color=default.color.main, 
                   ggtheme = theme_gray(), xlab='Cuantiles teóricos', 
                   ylab='Cuantiles de la muestra', title='Gráfico Q-Q', 
                   shape=16) + title.centered + xlab('') + ylab('')
          )

lillie.test(selected.houses$m2)
```

Las gráficas muestran que la superficie (m^2) de las viviendas no sigue una distribución normal; con el test de normalidad de Lilliefors se confirma que la distribución de la variable `m2` no es normal (p-value < $\alpha$ = 0.05). Se concluye por tanto que la variable `m2` no sigue una distribución normal.

### Normalidad de `price.m2`

Se procede a realizar las comprobaciones de normalidad en la variable `price.m2`, utilizando el test de Lilliefors y la ayuda de gráficas auxiliares.

```{r fig.height=5, fig.width=10}
price.m2.n <- length(selected.houses$price.m2)
price.m2.mean <- mean(selected.houses$price.m2)
price.m2.sd <- sd(selected.houses$price.m2)

ggarrange(nrow=1, ncol=2, align='hv', heights=c(1, 0.75),
          ggplot(selected.houses, aes(x=price.m2)) +
            geom_density(mapping=aes(y=..density..), fill=default.color.main) +
            geom_vline(xintercept=price.m2.mean, size=1.05,
                       linetype='dashed', color='gray50') +
            stat_function(fun=dnorm, args=c(mean=price.m2.mean,
                                            sd=price.m2.sd),
                          color=default.color.secondary, size=1.15) +
            no.axis.y + xlab('Precio/m2') + ylab('') + title.centered +
            ggtitle('Distribución de los precios de las viviendas', 
                    subtitle='Respecto a una distribución normal'),
          
          ggqqplot(selected.houses$price.m2, color=default.color.main, 
                   ggtheme = theme_gray(), xlab='Cuantiles teóricos', 
                   ylab='Cuantiles de la muestra', title='Gráfico Q-Q', 
                   shape=16) + title.centered + xlab('') + ylab('')
          )

lillie.test(selected.houses$price.m2)
```

Las gráficas muestran que el precio por metro cuadrado de las viviendas no sigue una distribución normal; con el test de normalidad de Lilliefors se confirma que la distribución de la variable `price.m2` no es normal (p-value < $\alpha$ = 0.05). Se concluye por tanto que la variable `price.m2` no sigue una distribución normal.

### Homocedasticidad de `price.m2` por barrios

Se procede a comprobar la homocedasticidad (también llamada homogeneidad de la varianza) del precio por metro cuadrado entre los barrios de Salamanca y Villaverde. Como los datos no siguen una distribución normal, se ha de utilizar el test de Fligner-Killeen, la alternativa no paramétrica al test de Levene.

```{r}
fligner.test(price.m2 ~ location, data=selected.houses)
```
El test de Fligner-Killeen produce un p-value < $\alpha$ = 0.05; por tanto, se rechaza la hipótesis nula de homocedasticidad y se concluye que el precio por metro cuadrado tiene varianzas estadísticamente diferentes para ambos barrios.

### Homocedasticidad de `price.m2` por barrios y alturas

Se procede a comprobar la homocedasticidad (también llamada homogeneidad de la varianza) del precio por metro cuadrado entre los barrios de Salamanca y Villaverde, según la altura a la que está situada la vivienda. Como los datos no siguen una distribución normal, se ha de utilizar el test de Fligner-Killeen, la alternativa no paramétrica al test de Levene.

```{r}
selected.houses.location.height <- selected.houses %>%
  dplyr::mutate(location.height.clasification=as.factor(
    paste0(as.character(location),'-',as.character(height.clasification))))

fligner.test(price.m2 ~ location.height.clasification, data=selected.houses.location.height)
```
El test de Fligner-Killeen produce un p-value < $\alpha$ = 0.05; por tanto, se rechaza la hipótesis nula de homocedasticidad y se concluye que el precio por metro cuadrado tiene varianzas estadísticamente diferentes para ambos barrios y criterios de altura.


## Pruebas estadísticas


# Conclusiones

# Tabla de contribuciones

A continuación se muestra cómo ambos miembros del equipo han participado en todas las tareas de este proyecto colaborativo: 

```{r, echo=FALSE}
contributions.table <- data.frame(Contribuciones = c("Investigación previa", 
                                                     "Redacción de las respuestas", 
                                                     "Desarrollo del código "), 
                                  Firma = c("AGV, PLT",
                                            "AGV, PLT",
                                            "AGV, PLT"))
contributions.table %>% 
  kable() %>% 
    kable_styling(bootstrap_options = Form.Basic)
```

# Bibliografía
